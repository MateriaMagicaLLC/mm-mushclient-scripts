<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, May 13, 2012, 4:43 PM -->
<!-- MuClient version 4.81 -->

<!-- Plugin "capture2dworld" generated by Plugin Wizard -->

<muclient>

<plugin
  name="capture2dworld"
  author="Ruthgul"
  id="b2772cad800b33a6073d9377"
  language="Lua"
  purpose="capture channels to a single dummy world"
  save_state="y"
  date_written="2012-05-13 16:42:17"
  date_modified="2021-01-26 09:52:34"
  requires="4.71"
  version="1.0"
>


<description trim="y">

<![CDATA[

.------------------.
 | capture2dworld |
`------------------'

Captures ct, at, tells, ft, public channels, etc. to a single dummy world window.


Features:
- It doesn't gag the original text in your screen.
- It retains the original colors.
- Text in the dummy world window can be selected and copied.
- Content management (beta): lets you filter out words and NPCs/PCs.


** REQUIRES **

The additional world file captures.MCL must be open.


Syntax:

> Capture types:

* clear captures  - to clear the captures window

* capture <channel_type>  - to start capturing that channel
* uncapture <channel_type>  - to stop capturing that channel

  where <channel_type> is one of the following:
    alliance|announce|archon|auction|aucverb|clan|form|guide|irc|ircverb|notify|novice|page|relay|say|shout|talk|tell|yell

* list captures  - to see the list of what's being captured


> Relay channels:

Note: don't include # when you add a channel - eg, use barter, not #barter.

* capture relay <name>  - to start capturing the relay channel
* uncapture relay <name>  - to stop capturing the relay channel

* list relays  - to see the lists of relay channel types


> Content filters (beta):
(... NPCs or PCs that will be omitted from captures, if they're not shifted)
* filter char <name>  - to add the NPC/PC to the exclusions list
* unfilter char <name>  - to remove the NPC/PC from the exclusions list

(... words that will be beeped out, with certain limitations)
* filter word <word>  - to add the word to the beeped list
* unfilter word <word>  - to remove the word from the beeped list

* list filters  - to see the lists of filtered NPCs/PCs and words


Author: Ruthgul

Latest version:
http://github.com/MateriaMagicaLLC/mm-mushclient-scripts

]]>

</description>

</plugin>



<!--  Variables  -->

<variables>

  <variable name="char_name">[a-zA-Z0-9 \-\,\.\'\(\)]+</variable>

</variables>



<!--  Aliases   -->

<aliases>

<!-- clear captures -->

  <alias
   enabled="y"
   match="^clear captures$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>clear_captures()
</send>
  </alias>


<!-- capture types -->

  <alias
   enabled="y"
   match="^capture (?P&lt;chantype&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>capture_chantype("%&lt;chantype&gt;")
</send>
  </alias>

  <alias
   enabled="y"
   match="^uncapture (?P&lt;chantype&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>uncapture_chantype("%&lt;chantype&gt;")
</send>
  </alias>

  <alias
   enabled="y"
   match="^list captures$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>list_captures()
</send>
  </alias>


<!-- relays -->

  <alias
   enabled="y"
   match="^list relays$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>list_relays(true)
</send>
  </alias>


<!-- content filters -->

  <alias
   enabled="y"
   match="^filter (?P&lt;type&gt;(char|word)) (?P&lt;name&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>add_content_filter("%&lt;type&gt;", "%&lt;name&gt;")
</send>
  </alias>

  <alias
   enabled="y"
   match="^unfilter (?P&lt;type&gt;(char|word)) (?P&lt;name&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>del_content_filter("%&lt;type&gt;", "%&lt;name&gt;")
</send>
  </alias>

  <alias
   enabled="y"
   match="^list filters$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>list_content_filters()
</send>
  </alias>


<!-- imms -->

  <alias
   enabled="y"
   match="^add imms$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>add_imms()
</send>
  </alias>

  <alias
   enabled="n"
   match="^simulate gecho$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>simulate()
</send>
  </alias>


<!--  Plugin help  -->

  <alias
   enabled="y"
   match="^capture2dworld(|( |\:)help)$"
   regexp="y"
   script="OnHelp"
  >
  </alias>

</aliases>



<!--  Triggers  -->

<triggers>

<!-- say -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(@!char_name)) (says|whispers|communicates) something to (.+)\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "say", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(You|(@!char_name))) (ask(| (.+))|asks(| you)|exclaim(| to (.+))|exclaims(| to you)|(say|whisper|communicate)(| to (.+))|(says|whispers|communicates)(| to you))\, \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "say", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\'(.+)\' (?P&lt;who&gt;(you|(.+))) (ask(| (.+))|asks(| you)|exclaim(| to (.+))|exclaims(| to you)|say(| to (.+))|says(| to you)|communicate(| to (.+))|communicates(| to you))\. \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "say", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\'(.+)\' (?P&lt;who&gt;(you|(.+))) (ask(| (.+))|asks(| you)|exclaim(| to (.+))|exclaims(| to you)|say(| to (.+))|says(| to you)|communicate(| to (.+))|communicates(| to you))\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "say", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^You hear (?P&lt;who&gt;.+) say through (.+)\: \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "say", "%0", true)
</send>
  </trigger>


<!-- shout -->

  <trigger
   enabled="y"
   ignore_case="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(@!char_name)) (shouts|SHOUTS) \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_shout("%&lt;who&gt;", "%0")
</send>
  </trigger>

  <trigger
   enabled="y"
   ignore_case="y"
   keep_evaluating="y"
   match="^\[[0-9]+\] people heard you shout \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "shout", "%0", true)
</send>
  </trigger>


<!-- tell -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(@!char_name)) tells you \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "tell", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^You tell [^ ]+ \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "tell", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(@!char_name)) impresses upon you \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "tell", "%0", true)
 </send>
   </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^You impress upon [^ ]+ \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "tell", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(@!char_name)) tells the formation \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "form", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^You tell the formation \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "form", "%0", true)
</send>
  </trigger>


<!-- yell -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(@!char_name)) yells \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_yell("%&lt;who&gt;", "%0")
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^You yell \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "yell", "%0", true)
</send>
  </trigger>


<!-- alliance -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[([0-9]+)\] alliance member(|s) heard you say\, \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "alliance", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^\[ALLIED [0-9]+\] (?P&lt;who&gt;(@!char_name))(| to \[[0-9]+\])\: \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_alliance("%&lt;who&gt;", "%0")
</send>
  </trigger>


<!-- announce -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^((?P&lt;who&gt;(@!char_name)) announces\, |A jovial voice tells you\, )\'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_announce("%&lt;who&gt;", "%0")
</send>
  </trigger>


<!-- archon or imm -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^\[[0-9]+\] ((@!char_name))\: (.+)$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_archon_talk("you", "%0")
</send>
  </trigger>


<!-- archon -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^\[ARCHON\] (?P&lt;who&gt;(@!char_name))\: (.+)$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "archon", "%0", false)
</send>
  </trigger>


<!-- clan -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[([0-9]+)\] clan member(|s) heard you say\, \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "clan", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^\[CLAN\] (?P&lt;who&gt;(@!char_name))\: \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_clan("%&lt;who&gt;", "%0")
</send>
  </trigger>


<!-- notify -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^(?P&lt;who&gt;[a-zA-Z]+) is currently logged in\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "notify", "%0", false)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^Signo(n|ff) at (.+) for (?P&lt;who&gt;.+) detected\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "notify", "%0", false)
</send>
  </trigger>


<!-- page -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^(?P&lt;who&gt;[a-zA-Z]+) is paging you\.\.\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
latest_pager = "%&lt;who&gt;"
capture_stuff("%&lt;who&gt;", "page", "%0", false)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^Reason: (.+)$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff(latest_pager or "", "page", "%0", false)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="You have paged *"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
latest_pager = "you"
capture_stuff("you", "page", "%0", false)
</send>
  </trigger>


<!-- [pk]talk -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[(PKTALK|TALK)(| (.+))\] (?P&lt;who&gt;[a-zA-Z ]+)\: \'(.+)\'(| \[[0-9]+\])$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "talk", "%0", false)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[(PKTALK|TALK)(| (.+))\] \'(.+)\'(| \[[0-9]+\])$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "talk", "%0", false)
</send>
  </trigger>


<!-- relay -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^(?P&lt;who&gt;[a-zA-Z\[\]]+)\@\#(?P&lt;chan&gt;[^ ]+)\: (.+)$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_relay("%&lt;who&gt;", "%&lt;chan&gt;", "%0")
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[([0-9]+)\] people in \#(?P&lt;chan&gt;[^ ]+) heard you relay \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_relay("you", "%&lt;chan&gt;", "%0")
</send>
  </trigger>


<!-- prayer -->

  <trigger
   enabled="y"
   group="prayer"
   keep_evaluating="y"
   match="^(?P&lt;who&gt;[a-zA-Z]+) \[(.+)\] prays \'(.+)\'(| \[HELLBANNED\])$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "guide", "%0", false)
</send>
  </trigger>


<!-- guide -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[GUIDE\] (?P&lt;who&gt;[a-zA-Z]+) (?P&lt;what&gt;.+)$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_guide("%&lt;who&gt;", "%&lt;what&gt;", "%0")
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[[0-9]+\] guide(|s) heard you say\, \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "guide", "%0", false)
</send>
  </trigger>


<!-- novice -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^\[CLAN Novice Adventurers\] (?P&lt;who&gt;(@!char_name))\: \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "novice", "%0", false)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[[0-9]+\] Novice clan member(|s) heard you say\, \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "novice", "%0", false)
</send>
  </trigger>


<!-- auction -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^AUCTION\: (?P&lt;who&gt;[a-zA-Z]+) has put (.+) up for auction\. Minimum bid is (.+) gp\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
latest_auctioner = "%&lt;who&gt;"
capture_stuff("%&lt;who&gt;", "auction", "%0", false)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^AUCTION\: (((.+)\: going (once|twice) (\(no bid received yet\)|going (once|twice) for (.+) gp to (.+))|has been sold to (.+) for (.+) gp|has removed (.+) from the auction queue)|(.+) bids (.+) gp on (.+)|No bids received for (.+)\. Item has been withdrawn)\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff(latest_auctioner or "", "aucverb", "%0", false)
</send>
  </trigger>


<!-- imm -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(@!imms))\: (?P&lt;what&gt;.+)$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_other("%&lt;who&gt;", "%&lt;what&gt;", "%0")
</send>
  </trigger>

</triggers>



<!--  Scripts  -->

<script>

<![CDATA[

require "wait"
require "gmcphelper"


-----------------
-- plugin stuff
-----------------

function OnPluginInstall()
  wait.make(function()
    Tell("-- " .. GetPluginInfo(GetPluginID(), 1) .. ": type ")
    ColourTell("silver", "black", GetPluginInfo(GetPluginID(), 1) .. " help")
    Note(" to see info about this plugin --")

    init_captures_list()

    -- give the plugins time to initialize
    wait.time(3)
    detect_plugins()
  end)
end


function detect_plugins()
  reader_present = reader_plugin_present()
end


function is_plugin_present(name, id)
  local res = false

  local plugin_name = GetPluginInfo(id, 1)

  if (plugin_name == name) then
    -- is it enabled?
    if (GetPluginInfo(id, 17)) then
      res = true
    end
  end

  return res
end


function OnHelp()
  ColourNote("silver", "black", world.GetPluginInfo(world.GetPluginID(), 3))
  Note("")
  ColourNote("silver", "black", "(this version: " .. os.date("%c", GetPluginInfo(GetPluginID(), 14)) .. ")")
end


function plugin_update_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/capture2dworld.xml",
  }
  return (table.concat(t, ";"))
end


function plugin_update_aux_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/res/captures.MCL,MUSH/worlds",
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/res/announce.mp3,MUSH/sounds",
  }
  return (table.concat(t, ";"))
end



-----------------
-- tables stuff
-----------------

function find_index(t, item)
  res = nil

  for i = 1, #t do
    if (string.lower(t[i]) == string.lower(item)) then
      res = i
      break
    end
  end

  return res
end


function add_to_table(t, item)
  local i = find_index(t, item)
  if (not i) then
    t[#t + 1] = item
    table.sort(t) -- keep it sorted alphabetically
  end
end


function del_from_table(t, item)
  local i = find_index(t, item)
  if (i) then
    table.remove(t, i)
  end
end



----------------
-- lists stuff
----------------

function list_to_table(list)
  local list = GetVariable(list)
  local t
  if (not list) or (list == "") then
    t = {}
  else
    t = utils.split(list, "|")
  end
  return t
end


function add_to_list(list, item)
  local t = list_to_table(list)
  add_to_table(t, item)
  SetVariable(list, table.concat(t, "|"))
end


function del_from_list(list, item)
  local t = list_to_table(list)
  del_from_table(t, item)
  SetVariable(list, table.concat(t, "|"))
end


function is_listed(list, item)
  local t = list_to_table(list)
  return (find_index(t, item) ~= nil)
end



---------
-- imms
---------

function add_imms()
  local oldlist = Trim(GetVariable("imms") or "")
  if (oldlist == "") then
    oldlist = "Duende|Elana|Esker|Iyara|Lanasar|Moirae|Omnis|Satina|Sekhet|Sueno"
  end
  oldlist = string.gsub(oldlist, "|", "\r\n")

  local list = utils.editbox("Type a list of names, one per line.\r\nPress OK when you're done.", "Imms", oldlist, "Lucida Console", 9)

  if (list) then
    while(string.find(list, "\r\n\r\n")) do
      list = string.gsub(list, "\r\n\r\n", "\r\n")
    end

    while(string.find(list, " ")) do
      list = string.gsub(list, " ", "")
    end

    list = string.gsub(list, "\r\n", "|")
    list = string.gsub(list, "\n", "|")
    list = string.gsub(list, "\r", "|")

    SetVariable("imms", list)
    SaveState()
  end
end



-------------------------
-- manage capture types
-------------------------

function init_captures_list()
  SetVariable("all_channel_types", "alliance|announce|archon|auction|aucverb|clan|form|guide|irc|ircverb|notify|novice|page|relay|say|shout|talk|tell|yell")

  local default_channel_types = "alliance|announce|archon|clan|form|guide|notify|novice|page|relay|shout|talk|tell|yell"

  local x = GetVariable("captures")
  if (x == nil) or (x == "") then
    -- default is full list minus auction|say
    SetVariable("captures", default_channel_types)
    SaveState()

  else
    if (string.find(x, "private")) then
      uncapture_chantype("private")
      capture_chantype("notify")
      capture_chantype("page")
      capture_chantype("tell")
    end

    if (string.find(x, "public")) then
      uncapture_chantype("public")
      capture_chantype("archon")
      capture_chantype("talk")
      capture_chantype("shout")
      capture_chantype("yell")
    end
  end

  BroadcastPlugin(0, GetVariable("captures"))
end


function capture_chantype(chantype)
  local t = utils.split(chantype, " ")

  if (t[1] == "relay") then
    if (t[2]) then
      add_relay(t[2])

    else
      Tell("-- capture2dworld: type ")
      ColourTell("silver", "black", "capture relay <chatroomname>")
      Note(" (eg, capture relay sightimpaired) --")
    end

  else
    if (is_listed("all_channel_types", t[1])) then
      if (not is_listed("captures", t[1])) then
        add_to_list("captures", t[1])
        SaveState()
        Tell("-- capture2dworld: added channel ")
        ColourTell("silver", "black", t[1])
        Note(" to the list of captures --")

        BroadcastPlugin(0, GetVariable("captures"))

      else
        Note("-- capture2dworld: '" .. t[1] .. "' is already in the list of captures --")
      end

    else
      Note("-- capture2dworld: '" .. t[1] .. "' is not supported --")
    end
  end
end


function uncapture_chantype(chantype)
  local t = utils.split(chantype, " ")

  if (t[1] == "relay") then
    del_relay(t[2])

  else
    if (is_listed("captures", t[1])) then
      del_from_list("captures", t[1])
      SaveState()
      Tell("-- capture2dworld: removed channel ")
      ColourTell("silver", "black", t[1])
      Note(" from the list of captures --")

      BroadcastPlugin(0, GetVariable("captures"))

    else
      Note("-- capture2dworld: '" .. t[1] .. "' is not in the list of captures --")
    end
  end
end


function get_captures_list()
  local aux = GetVariable("captures") or "-"

  return aux
end


function list_captures()
  Note("-- capture2dworld --")
  Tell("* showing channel types: ")

  local capt = GetVariable("captures") or "-"
  capt = string.gsub(capt, "|", ", ")

  local all = GetVariable("all_channel_types") or "-"
  all = string.gsub(all, "|", ", ")

  ColourNote("silver", "black", capt)
  Note("(out of this full list: " .. all .. ")")

  list_relays(false)
end



------------------
-- manage relays
------------------

function add_relay(rname)
  if (not is_listed("captures", "relay")) then
    capture_chantype("relay")
  end

  if (not is_listed("relays", rname)) then
    add_to_list("relays", rname)
    SaveState()
    Tell("-- capture2dworld: added relay ")
    ColourTell("silver", "black", rname)
    Note(" to the list of captures --")

  else
    Note("-- capture2dworld: that relay is already in the list of captures --")
  end
end


function del_relay(rname)
  if (is_listed("relays", rname)) then
    del_from_list("relays", rname)
    SaveState()
    Tell("-- capture2dworld: removed relay ")
    ColourTell("silver", "black", rname)
    Note(" from the list of captures --")

  else
    Note("-- capture2dworld: that relay is not in the list of captures --")
  end
end


function list_relays(show_header)
  if (show_header) then
    Note("-- capture2dworld --")
  end

  local rel = GetVariable("relays") or "-"
  rel = string.gsub(rel, "|", ", ")

  Tell("* showing relays: ")
  ColourNote("silver", "black", rel)
end



---------------------------
-- manage content filters
---------------------------

function add_content_filter(ftype, fname)
  -- ftype is char|word

  fname = Trim(fname)
  local aux = string.lower(fname)

  ftype = "filtered_" .. ftype .. "s"

  if (not is_listed(ftype, aux)) then
    add_to_list(ftype, aux)
    SaveState()
    Tell("-- capture2dworld: added " .. ftype .. " ")
    ColourTell("silver", "black", fname)
    Note(" to the list of filters --")

  else
    Note("-- capture2dworld: " .. fname .. " is already in the " .. ftype .. " list --")
  end
end


function del_content_filter(ftype, fname)
  -- ftype is char|word

  fname = Trim(fname)
  local aux = string.lower(fname)

  ftype = "filtered_" .. ftype .. "s"

  if (is_listed(ftype, aux)) then
    del_from_list(ftype, aux)
    SaveState()
    Tell("-- capture2dworld: removed " .. ftype .. " ")
    ColourTell("silver", "black", fname)
    Note(" from the list of filters --")

  else
    Note("-- capture2dworld: " .. fname .. " is not in the " .. ftype .. " list --")
  end
end


function list_content_filters()
  Note("-- capture2dworld: content filters --")
  Tell("* NPCs / PCs: ")
  ColourNote("silver", "black", GetVariable("filtered_chars") or "-")
  Tell("* words: ")
  ColourNote("silver", "black", GetVariable("filtered_words") or "-")
end



---------
-- gags
---------

function is_gagged(name)
  local res, val

  res, val = CallPlugin("8928fc500d37775d54b86a56", "is_gagged", name)

  if (res ~= 0) then
    val = nil
  end

  return val
end



----------------------------------
-- broadcasts from other plugins
----------------------------------

function OnPluginBroadcast(msg, id, pname, text)
  if (id == "51a661f409c5d66601ff16e9") -- comm_stuff
  and (pname == "comm_stuff") then
    if (msg == 1) then
      handle_irc_msg(text)
    end

  elseif (id == "f67c4339ed0591a5b010d05b") then -- GMCP message
    if (text == "char.gecho_notification") then -- gecho
      get_gmcp_gecho()
      handle_gmcp_gecho()
    end

  elseif (id == "fbd5b7cc1ef6acf827a3f4a1") -- plugins_updater_v2
  or (id == "5945aedf1aacc09e42c48cef") then -- plugins_updater_v3
    if (msg == 1) then
      Note(text)
      handle_gmcp_gecho(text)
    end
  end
end



---------
-- gmcp
---------

function get_gmcp_gecho()
  local res, gmcparg = CallPlugin("f67c4339ed0591a5b010d05b", "gmcpval", "char.gecho_notification")
  luastmt = "gmcpdata = " .. gmcparg

--  Note("gmcparg: " .. (gmcparg or "nil"))

  assert(loadstring(luastmt or ""))()
end


function simulate()
  handle_gmcp_gecho("debug")
end


function do_simulate()
  local t_sims = {
    "\n\r\n\r|W|Z117Humpty|X |z117Dumpty|X|X\n\r\n\r",
    "\n\r\n\r|W|Z039Humpty Dumpty|X|X\n\r\n\r",
    "\n\r\n\r|Wjack |z189jump |1over |Xthe |1|z213candlestick|x|X\n\r\n\r",
    "\n\r\n\r|W|z188jack |xbe |Cquick|X\n\r\n\r",
    "\n\r\n\r|W|z157jack be nimble|X|X\n\r\n\r",
    "\n\r\n\r|W|z117 all the night|X|X\n\r\n\r",
    "\n\r\n\r|W|z105 twinkle, twinkle,|X|X\n\r\n\r",
    "\n\r\n\r|W|X|2|RThen you show your |3|Clittle light|X|X\n\r\n\r",
    "\n\r\n\r|W|X|1|Rwhen nothing shines above|X|X\n\r\n\r",
    "\n\r\n\r|W|X|1|Gwhen the blazing sun is gone|X|X\n\r\n\r",
    "\n\r\n\r|W|1like |Xa |Wdiamond|X in the |Csky|X\n\r\n\r",
    "\n\r\n\r|Wthe |bworld |Xso high|X\n\r\n\r",
    "\n\r\n\r|Wup |Rabove|X\n\r\n\r",
    "\n\r\n\r|W|Cwho you |gare|X\n\r\n\r",
    "\n\r\n\r|W|Yhow I wonder|X\n\r\n\r",
    "\n\r\n\r|W|Blittle star|X\n\r\n\r",
    "\n\r\n\r|Wtwinkle twinkle|X\n\r\n\r",
  }

  return t_sims[math.random(#t_sims)]
end


function handle_gmcp_gecho(msg)
  if (not msg) then
    msg = gmcpval("gecho_msg")

  elseif (msg == "debug") then
    msg = do_simulate()

  --msg not nil, not "debug" => process it as it comes
  end

  if (reader_present) then
    handle_gmcp_gecho_v1_nocolors(msg)
  else
    handle_gmcp_gecho_v2_colors(msg)
  end
end


function handle_gmcp_gecho_v1_nocolors(msg)
  if (msg) then
    msg = strip_colors(msg)
    msg = strip_crlfs(msg)

    for line in string.gmatch(msg, "[^§]*§") do
      line = string.match(line, "(.+)§")
      line = Trim(line or "")

      if (line ~= "") then
--        Note("broadcasting: " .. line)
        broadcast_txt_line("announce", line, "")
      end
    end
  end
end


function handle_gmcp_gecho_v2_colors(msg)
  if (msg) then
    captures = GetWorld("captures") -- checks every time, in case they close it

    show_txt("silver", "black", "\r\n")
    show_txt("silver", "black", "[".. os.date("%H:%M:%S") .. "] ")
--    show_txt("orangered", "black", "[gecho] ")

    local aux = strip_crlfs(msg)

    local fg, bg, col, txt
    fg = "silver"
    bg = "black"

    for x in string.gmatch(aux, "|[^|]*") do
      if (string.find(x, "^|z%d%d%d")) then
        col, txt = string.match(x, "^|z(%d%d%d)(.*)")
        col = RGBColourToName(x256_to_rgb(tonumber(col)))
        if (col) then
          fg = col
        end

      elseif (string.find(x, "^|Z%d%d%d")) then
        col, txt = string.match(x, "^|Z(%d%d%d)(.*)")
        col = RGBColourToName(x256_to_rgb(tonumber(col)))
        if (col) then
          bg = col
        end

      elseif (string.find(x, "^|X")) then
        fg = "silver"
        bg = "black"
        txt = string.match(x, "^|X(.*)")

      elseif (string.find(x, "^|%a")) then
        col, txt = string.match(x, "^|(%a)(.*)")
        col = fg_mm_to_name(col)
        if (col) then
          fg = col
        end

      elseif (string.find(x, "^|%d")) then
        col, txt = string.match(x, "^|(%d)(.*)")
        col = bg_mm_to_name(col)
        if (col) then
          bg = col
        end
      end

      if (txt) then
        if (string.find(txt, "§")) then
          for line in string.gmatch(txt, "[^§]*§") do
            line = string.match(line, "(.+)§")
            line = Trim(line or "")

            if (line ~= "") then
              show_txt(fg, bg, line)

              broadcast_txt_line("announce", line, "")
            end

            show_txt("silver", "black", "\r\n")
          end

        else
          show_txt(fg, bg, txt)

          broadcast_txt_line("announce", txt, "")
        end
      end
    end
  end
end


function strip_colors(msg)
  local res = ""

--  for x in string.gmatch(msg, "[|]*[^|]+") do

  res = string.gsub(msg, "|[xz]%d%d%d", "")
  res = string.gsub(res, "|[%d%a]", "")
  res = Trim(res)

--  end

  return res, white
end


function strip_crlfs(msg)
  msg = string.gsub(msg, "\r", "§")
  msg = string.gsub(msg, "\n", "§")
  msg = msg .. "§"

  while (string.find(msg, "§§")) do
    msg = string.gsub(msg, "§§", "§")
  end

  return msg
end



-----------------------
-- MM colors to names
-----------------------

local code_to_name = {
  ["1"] = "maroon",
  ["2"] = "green",
  ["3"] = "olive",
  ["4"] = "navy",
  ["5"] = "purple",
  ["6"] = "teal",
  ["7"] = "silver",
  ["B"] = "blue",
  ["R"] = "red",
  ["C"] = "cyan",
  ["M"] = "magenta",
  ["Y"] = "yellow",
  ["W"] = "white",
  ["G"] = "lime",
  ["b"] = "navy",
  ["r"] = "maroon",
  ["c"] = "teal",
  ["m"] = "purple",
  ["y"] = "olive",
  ["w"] = "silver",
  ["g"] = "green",
  ["D"] = "gray",
}


function fg_mm_to_name(color)
  local res = code_to_name[color]

  return res
end


function bg_mm_to_name(color)
  local res = code_to_name[color]

  return res
end



----------------
-- x256 to RGB
----------------

local compatibility_16_to_rgb = {
  [0] = 0, -- black
  [1] = 128, -- maroon
  [2] = 32768, -- green
  [3] = 32896, -- olive
  [4] = 8388608, -- navy
  [5] = 8388736, -- purple
  [6] = 8421376, -- teal
  [7] = 12632256, -- silver
  [8] = 8421504, -- gray
  [9] = 255, -- red
  [10] = 65280, -- lime
  [11] = 65535, -- yellow
  [12] = 16711680, -- blue
  [13] = 16711935, -- magenta
  [14] = 16776960, -- cyan
  [15] = 16777215, -- white
}


function x256_to_rgb(x256)
  local r, g, b, rgb

  if (x256 >= 0) and (x256 <= 15) then
    -- compatibility 16
    rgb = compatibility_16_to_rgb[x256]

  elseif (x256 >= 16) and (x256 <= 231) then
    -- cube
    x256 = x256 - 16

    r = math.floor(x256 / 6 / 6)
    x256 = x256 - (r * 6 * 6)
    g = math.floor(x256 / 6)
    b = x256 - (g * 6)

    rgb = (256 * 256 * to255(b)) + (256 * to255(g)) + to255(r)

  elseif (x256 >= 232) and (x256 <= 255) then
    -- grayscale
    x256 = x256 - 232

    rgb = (256 * 256 * to255gray(x256)) + (256 * to255gray(x256)) + to255gray(x256)
  end

  return rgb
end


function to255(num)
  return num * 51
end


function to255gray(num)
  return 8 + (num * 10)
end



--------
-- irc
--------

function handle_irc_msg(text)
--  Note("Got an IRC msg")
  if (is_listed("captures", "irc"))
  or (is_listed("captures", "ircverb"))  then
--    Note("Capturing IRC msgs")
    local user, extuser, msg = string.match(text, "(.+);(.+);(.+)")

--    Note("user: " .. (user or "nil"))
--    Note("extuser: " .. (extuser or "nil"))
--    Note("msg: " .. (msg or "nil"))

    if (not string.match(msg, "^§.+"))
    or (is_listed("captures", "ircverb")) then
      captures = GetWorld("captures") -- gotta check every time in case they close it
--      Note("trying to show it")
      show_txt("silver", "black", "\r\n")
      show_txt("silver", "black", "[".. os.date("%H:%M:%S") .. "] ")
      show_txt("springgreen", "black", "[irc] ")
      show_txt("white", "black", extuser .. ": ")

      if (string.find(extuser, "#")) then
        show_txt("silver", "text", msg)
      else
        show_txt("gray", "text", msg)
      end

      show_txt("silver", "black", "\r\n")
    end
  end
end



------------------
-- show captures
------------------

function capture_stuff(who, type, line, recolor)
-- who needs to be not nil,
  if (type ~= "relay") then
    -- broadcast _unfiltered_ text-only info, for capture2notepads and similar plugins
    broadcast_txt_line(type, line, who)
  end

  if (is_listed("captures", type)) then
--    if (type ~= "guide") then
      -- check if the person is being filtered out
      who = string.lower(extract_name(who))

      if (not is_listed("filtered_chars", who))
      and (not is_gagged(who)) then
        add_to_captures_world(who, type, recolor)
      end

--    else
--    -- we DON'T apply filters to guide
--      add_to_captures_world(who, type, recolor)
--    end
  end
end


function broadcast_txt_line(type, line, who)
  -- broadcast text-only info, for capture2notepads and similar plugins
  local t = {
    [1] = type,
    [2] = line,
    [3] = who,
  }
  BroadcastPlugin(2, table.concat(t, "Ø"))
end


function extract_name(name)
  if (string.find(name, "^The shade of ")) then
    name = string.gsub(name, "^The shade of ", "")

  elseif (string.find(name, "([%s%p])disguised as ")) then
    name = string.gsub(name, "%pdisguised as ", "disguised as ")
    name, _ = string.match(name, "(.+) disguised as (.+)")
  end

  return name
end


function add_to_captures_world(who, type, recolor)
  local txt, fgcol, bgcol

  captures = GetWorld("captures") -- gotta check every time in case they close it

  show_txt("silver", "black", "\r\n")
  show_txt("silver", "black", "[".. os.date("%H:%M:%S") .. "] ")

  for i = 1, #trigger_style_runs do
    txt = trigger_style_runs[i].text

    -- shorten Novice clan name
    if (string.find(txt, "Novice")) then
      txt = string.gsub(txt, "%[CLAN Novice Adventurers%]", "%[Novice%]")
      txt = string.gsub(txt, "Novice clan members", "Novices")
      txt = string.gsub(txt, "Novice clan member", "Novice")
    end

    -- shorten Vandemaar's Magic Mirror
    if (string.find(txt, "Vandemaar's Magic Mirror")) then
      txt = string.gsub(txt, "^You hear (.+) say through Vandemaar's Magic Mirror:", "%(mirror%) %1:")
    end

    -- we only apply word filters if it isn't the guide channel
    if (type ~= "guide") then
      -- filter out words in the message
      txt = filter_all_words(txt)
    end

    fgcol = RGBColourToName(trigger_style_runs[i].textcolour)
    bgcol = RGBColourToName(trigger_style_runs[i].backcolour)

    show_txt(fgcol, bgcol, txt)
  end

  show_txt("silver", "black", "\r\n")
end


function show_txt(fgcol, bgcol, txt)
  if (captures) then
    captures:ColourTell(fgcol, bgcol, txt)
  end

  -- broadcast _filtered_ info, for capture2mini and similar plugins
  local t = {
    [1] = fgcol,
    [2] = bgcol,
    [3] = txt,
  }
  BroadcastPlugin(1, table.concat(t, "Ø"))
end


function clear_captures()
  local captures = GetWorld("captures")
  if (captures ~= nil) then
    captures:DeleteOutput()
    captures:Pause(false)
  end
end



----------------------
-- filtered captures
----------------------

function capture_alliance(who, line)
  -- add to this table the list of stuff that you don't want to be captured
  -- eg, keywords from bots output
  local omit_from_alliance = {
  }

  for i = 1, #omit_from_alliance do
    if (string.find(line, omit_from_alliance[i])) then
      return
    end
  end

  capture_stuff(who, "alliance", line, true)
end


function capture_announce(who, line)
  -- do include arena results
  if (string.find(line, "has been slain by"))
  and (string.find(line, "in Arena combat")) then
    capture_stuff(who, "announce", line, false)
    return
  end

  -- add to this table the list of stuff that you don't want to be captured
  local omit_from_announce = {
    "A Capture The Flag coordinator announces",
    "has the blue flag",
    "has the red flag",
    "has recovered the blue flag",
    "has recovered the red flag",
    "has scored a point for the blue team",
    "has scored a point for the red team",
    "has been slain by",
    "has reduced my integrity by",
    "Feel my demise in your heart",
    "An election official for the Towne of Rune announces",
  }

  for i = 1, #omit_from_announce do
    if (string.find(line, omit_from_announce[i])) then
      return
    end
  end

  capture_stuff(who, "announce", line, false)
end


function capture_archon_talk(who, line)
  -- add to this table the list of stuff that you don't want to be captured
  local omit_from_archon_talk = {
  }

  for i = 1, #omit_from_archon_talk do
    if (string.find(line, omit_from_archon_talk[i])) then
      return
    end
  end

  capture_stuff(who, "archon", line, false)
end


function capture_clan(who, line)
  -- add to this table the list of stuff that you don't want to be captured
  -- eg, keywords from bots output
  local omit_from_clan = {
  }

  for i = 1, #omit_from_clan do
    if (string.find(line, omit_from_clan[i])) then
      return
    end
  end

  capture_stuff(who, "clan", line, true)
end


function capture_guide(who, what, line)
  -- add to this table the list of stuff that you don't want to be captured
  local omit_from_guide = {
    "There are no player guides currently enabled",
    "idling in Lasler: If you can and nobody else has",
    "has joined the game at",
  }

  for i = 1, #omit_from_guide do
    if (string.find(line, omit_from_guide[i])) then
      return
    end
  end

  local t = utils.split(what, " ")
  if (t[1] == "says") then
    capture_stuff(who, "guide", line, false)
  else
    capture_stuff("", "guide", line, false)
  end
end


function capture_other(who, what, line)
  if (not string.match(what, "^ (%s+)(.+)"))
  and (not string.match(what, "^(%s+)%[(.+)")) then
    capture_stuff(who, "guide", line, false)
  end
end


function capture_relay(who, chan, line)
  -- broadcast _unfiltered_ text-only info, for capture2notepads and similar plugins
  broadcast_txt_line("relay", line, who)

  if (is_listed("relays", chan)) then
    capture_stuff(who, "relay", line, false)
  end
end


function capture_shout(who, line)
  -- add to this table the list of stuff that you don't want to be captured
  -- eg, certain game announcements
  local omit_from_shout = {
    "Shop the fine wares at the Alyrian Bazaar",
    "Hear ye, hear ye, adventurers of",
    "back from a long absence!",
  }

  for i = 1, #omit_from_shout do
    if (string.find(line, omit_from_shout[i])) then
      return
    end
  end

  capture_stuff(who, "shout", line, true)
end


function capture_yell(who, line)
  -- add to this table the list of stuff that you don't want to be captured
  -- eg, certain game announcements
  local omit_from_yell = {
    "available in Agatha's Shoppe of Illusions!",
    "A masculine voice yells",
    "Ferry is now docked at",
    "The ship Merdraco be docked at",
    "Step right up, step right up!",
    "If you'd like information on quests, please visit me at the Shrine of St. Wisehart!",
    "Unbreakable, level-scaling weapons for sale in the village's main street, near the Shrine!",
    "Come visit the Crystal Guild's hall near the cemetery",
  }

  for i = 1, #omit_from_yell do
    if (string.find(line, omit_from_yell[i])) then
      return
    end
  end

  capture_stuff(who, "yell", line, true)
end



-----------------
-- filter words
-----------------

function nocase(s)
  s = string.gsub(s, "%a",
                  function(c)
                    return string.format("[%s%s]",
                                         string.lower(c),
                                         string.upper(c))
      end)
  return s
end


function filter_word(s, word)
  beeped_subst = "*beeped*" -- edit this if you don't like it

  -- just the word
  s = string.gsub(s, "^" .. nocase(word) .. "$", beeped_subst)

  -- beginning of the line
  s = string.gsub(s, "^" .. nocase(word) .. "([%p%s])", beeped_subst .. "%1")

  -- end of the line
  s = string.gsub(s, "([%p%s])" .. nocase(word) .. "$", "%1" .. beeped_subst)

  -- middle of the line
  s = string.gsub(s, "([%p%s])" .. nocase(word) .. "([%s%p])", "%1" .. beeped_subst .. "%2")

  return s
end


function filter_all_words(s)
  tfilter = list_to_table("filtered_words")

  for i = 1, #tfilter do
    s = filter_word(s, tfilter[i])
  end

  return s
end



----------------
-- sound stuff
----------------

function reader_plugin_present()
  return is_plugin_present("MushReader", "925cdd0331023d9f0b8f05a7")
end


]]>

</script>

</muclient>
