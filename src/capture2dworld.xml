<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, May 13, 2012, 4:43 PM -->
<!-- MuClient version 4.81 -->

<!-- Plugin "capture2dworld" generated by Plugin Wizard -->

<muclient>

<plugin
   name="capture2dworld"
   author="Ruthgul"
   id="b2772cad800b33a6073d9377"
   language="Lua"
   purpose="capture channels to a single dummy world"
   save_state="y"
   date_written="2012-05-13 16:42:17"
   date_modified="2015-04-17 07:01:31"
   requires="4.71"
   version="1.0"
   >


<description trim="y">

<![CDATA[

.------------------.
 | capture2dworld |
`------------------'

Captures ct, at, tells, ft, public channels, etc. to a single dummy world window.


Features:
- It doesn't gag the original text in your screen.
- It retains the original colors.
- Text in the dummy world window can be selected and copied.
- Content management (beta): lets you filter out words and NPCs/PCs.


** REQUIRES **

The additional world file captures.MCL must be open.


Syntax:

> Capture types:

* clear captures  - to clear the captures window

* capture <channel_type>  - to start capturing that channel
* uncapture <channel_type>  - to stop capturing that channel

  where <channel_type> is one of the following:
    alliance|announce|archon|auction|aucverb|clan|form|guide|irc|ircverb|notify|novice|page|relay|say|shout|talk|tell|yell

* list captures  - to see the list of what's being captured


> Relay channels:

Note: don't include # when you add a channel - eg, use barter, not #barter.

* capture relay <name>  - to start capturing the relay channel
* uncapture relay <name>  - to stop capturing the relay channel

* list relays  - to see the lists of relay channel types


> Content filters (beta):
(... NPCs or PCs that will be omitted from captures, if they're not shifted)
* filter char <name>  - to add the NPC/PC to the exclusions list
* unfilter char <name>  - to remove the NPC/PC from the exclusions list

(... words that will be beeped out, with certain limitations)
* filter word <word>  - to add the word to the beeped list
* unfilter word <word>  - to remove the word from the beeped list

* list filters  - to see the lists of filtered NPCs/PCs and words


Author: Ruthgul

Latest version:
http://github.com/MateriaMagicaLLC/mm-mushclient-scripts

]]>

</description>

</plugin>



<!--  Variables  -->

<variables>

  <variable name="char_name">[a-zA-Z0-9 \-\,\.\'\(\)]+</variable>

</variables>



<!--  Aliases   -->

<aliases>

<!-- clear captures -->

  <alias
   enabled="y"
   match="^clear captures$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>clear_captures()
</send>
  </alias>


<!-- capture types -->

  <alias
   enabled="y"
   match="^capture (?P&lt;chantype&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>capture_chantype("%&lt;chantype&gt;")
</send>
  </alias>

  <alias
   enabled="y"
   match="^uncapture (?P&lt;chantype&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>uncapture_chantype("%&lt;chantype&gt;")
</send>
  </alias>

  <alias
   enabled="y"
   match="^list captures$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>list_captures()
</send>
  </alias>


<!-- relays -->

  <alias
   enabled="y"
   match="^list relays$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>list_relays(true)
</send>
  </alias>


<!-- content filters -->

  <alias
   enabled="y"
   match="^filter (?P&lt;type&gt;(char|word)) (?P&lt;name&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>add_content_filter("%&lt;type&gt;", "%&lt;name&gt;")
</send>
  </alias>

  <alias
   enabled="y"
   match="^unfilter (?P&lt;type&gt;(char|word)) (?P&lt;name&gt;.+)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>del_content_filter("%&lt;type&gt;", "%&lt;name&gt;")
</send>
  </alias>

  <alias
   enabled="y"
   match="^list filters$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>list_content_filters()
</send>
  </alias>


<!-- imms -->

  <alias
   enabled="y"
   match="^add imms$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>add_imms()
</send>
  </alias>

  <alias
   enabled="n"
   match="^simulate gecho$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>simulate()
</send>
  </alias>


<!--  Plugin help  -->

  <alias
   enabled="y"
   match="^capture2dworld(|( |\:)help)$"
   regexp="y"
   script="OnHelp"
  >
  </alias>

</aliases>



<!--  Triggers  -->

<triggers>

<!-- say -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(@!char_name)) (says|whispers) something to (.+)\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "say", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(You|(@!char_name))) (ask(| (.+))|asks(| you)|exclaim(| to (.+))|exclaims(| to you)|(say|whisper)(| to (.+))|(says|whispers)(| to you))\, \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "say", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\'(.+)\' (?P&lt;who&gt;(you|(.+))) (ask(| (.+))|asks(| you)|exclaim(| to (.+))|exclaims(| to you)|say(| to (.+))|says(| to you))\. \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "say", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\'(.+)\' (?P&lt;who&gt;(you|(.+))) (ask(| (.+))|asks(| you)|exclaim(| to (.+))|exclaims(| to you)|say(| to (.+))|says(| to you))\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "say", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^You hear (?P&lt;who&gt;.+) say through (.+)\: \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "say", "%0", true)
</send>
  </trigger>


<!-- shout -->

  <trigger
   enabled="y"
   ignore_case="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(@!char_name)) (shouts|SHOUTS) \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_shout("%&lt;who&gt;", "%0")
</send>
  </trigger>

  <trigger
   enabled="y"
   ignore_case="y"
   keep_evaluating="y"
   match="^\[[0-9]+\] people heard you shout \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "shout", "%0", true)
</send>
  </trigger>


<!-- tell -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(@!char_name)) tells you \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "tell", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^You tell [^ ]+ \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "tell", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(@!char_name)) tells the formation \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "form", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^You tell the formation \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "form", "%0", true)
</send>
  </trigger>


<!-- yell -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(@!char_name)) yells \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_yell("%&lt;who&gt;", "%0")
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^You yell \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "yell", "%0", true)
</send>
  </trigger>


<!-- alliance -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[([0-9]+)\] alliance member(|s) heard you say\, \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "alliance", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^\[ALLIED [0-9]+\] (?P&lt;who&gt;(@!char_name))(| to \[[0-9]+\])\: \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_alliance("%&lt;who&gt;", "%0")
</send>
  </trigger>


<!-- announce -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^((?P&lt;who&gt;(@!char_name)) announces\, |A jovial voice tells you\, )\'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_announce("%&lt;who&gt;", "%0")
</send>
  </trigger>


<!-- archon or imm -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^\[[0-9]+\] ((@!char_name))\: (.+)$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_archon_talk("you", "%0")
</send>
  </trigger>


<!-- archon -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^\[ARCHON\] (?P&lt;who&gt;(@!char_name))\: (.+)$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "archon", "%0", false)
</send>
  </trigger>


<!-- clan -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[([0-9]+)\] clan member(|s) heard you say\, \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "clan", "%0", true)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^\[CLAN\] (?P&lt;who&gt;(@!char_name))\: \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_clan("%&lt;who&gt;", "%0")
</send>
  </trigger>


<!-- notify -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^(?P&lt;who&gt;[a-zA-Z]+) is currently logged in\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "notify", "%0", false)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^Signo(n|ff) at (.+) for (?P&lt;who&gt;.+) detected\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "notify", "%0", false)
</send>
  </trigger>


<!-- page -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^(?P&lt;who&gt;[a-zA-Z]+) is paging you\.\.\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
latest_pager = "%&lt;who&gt;"
capture_stuff("%&lt;who&gt;", "page", "%0", false)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^Reason: (.+)$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff(latest_pager or "", "page", "%0", false)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="You have paged *"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
latest_pager = "you"
capture_stuff("you", "page", "%0", false)
</send>
  </trigger>


<!-- [pk]talk -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[(PKTALK|TALK)(| (.+))\] (?P&lt;who&gt;[a-zA-Z ]+)\: \'(.+)\'(| \[[0-9]+\])$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "talk", "%0", false)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[(PKTALK|TALK)(| (.+))\] \'(.+)\'(| \[[0-9]+\])$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "talk", "%0", false)
</send>
  </trigger>


<!-- relay -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^(?P&lt;who&gt;[a-zA-Z]+)\@\#(?P&lt;chan&gt;[^ ]+)\: (.+)$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_relay("%&lt;who&gt;", "%&lt;chan&gt;", "%0")
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[([0-9]+)\] people in \#(?P&lt;chan&gt;[^ ]+) heard you relay \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_relay("you", "%&lt;chan&gt;", "%0")
</send>
  </trigger>


<!-- prayer -->

  <trigger
   enabled="y"
   group="prayer"
   keep_evaluating="y"
   match="^(?P&lt;who&gt;[a-zA-Z]+) \[(.+)\] prays \'(.+)\'(| \[HELLBANNED\])$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "guide", "%0", false)
</send>
  </trigger>


<!-- guide -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[GUIDE\] (?P&lt;who&gt;[a-zA-Z]+) (?P&lt;what&gt;.+)$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_guide("%&lt;who&gt;", "%&lt;what&gt;", "%0")
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[[0-9]+\] guide(|s) heard you say\, \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "guide", "%0", false)
</send>
  </trigger>


<!-- novice -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^\[CLAN Novice Adventurers\] (?P&lt;who&gt;(@!char_name))\: \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("%&lt;who&gt;", "novice", "%0", false)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[[0-9]+\] Novice clan member(|s) heard you say\, \'(.+)\'$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff("you", "novice", "%0", false)
</send>
  </trigger>


<!-- auction -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^AUCTION\: (?P&lt;who&gt;[a-zA-Z]+) has put (.+) up for auction\. Minimum bid is (.+) gp\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
latest_auctioner = "%&lt;who&gt;"
capture_stuff("%&lt;who&gt;", "auction", "%0", false)
</send>
  </trigger>

  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^AUCTION\: (((.+)\: going (once|twice) (\(no bid received yet\)|going (once|twice) for (.+) gp to (.+))|has been sold to (.+) for (.+) gp|has removed (.+) from the auction queue)|(.+) bids (.+) gp on (.+)|No bids received for (.+)\. Item has been withdrawn)\.$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_stuff(latest_auctioner or "", "aucverb", "%0", false)
</send>
  </trigger>


<!-- imm -->

  <trigger
   enabled="y"
   keep_evaluating="y"
   expand_variables="y"
   match="^(?P&lt;who&gt;(@!imms))\: (?P&lt;what&gt;.+)$"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>trigger_style_runs = TriggerStyleRuns
capture_other("%&lt;who&gt;", "%&lt;what&gt;", "%0")
</send>
  </trigger>

</triggers>



<!--  Scripts  -->

<script>

<![CDATA[

require "wait"
require "gmcphelper"


-----------------
-- plugin stuff
-----------------

function OnPluginInstall()
  wait.make(function()
    Tell("-- " .. GetPluginInfo(GetPluginID(), 1) .. ": type ")
    ColourTell("silver", "black", GetPluginInfo(GetPluginID(), 1) .. " help")
    Note(" to see info about this plugin --")

    init_captures_list()

    -- give the plugins time to initialize
    wait.time(3)
    detect_plugins()
  end)
end


function detect_plugins()
  reader_present = reader_plugin_present()
end


function is_plugin_present(name, id)
  local res = false

  local plugin_name = GetPluginInfo(id, 1)

  if (plugin_name == name) then
    -- is it enabled?
    if (GetPluginInfo(id, 17)) then
      res = true
    end
  end

  return res
end


function OnHelp()
  ColourNote("silver", "black", world.GetPluginInfo(world.GetPluginID(), 3))
  Note("")
  ColourNote("silver", "black", "(this version: " .. os.date("%c", GetPluginInfo(GetPluginID(), 14)) .. ")")
end


function plugin_update_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/src/capture2dworld.xml",
  }
  return (table.concat(t, ";"))
end


function plugin_update_aux_url()
  local t = {
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/res/captures.MCL,MUSH/worlds",
    "https://raw.githubusercontent.com/MateriaMagicaLLC/mm-mushclient-scripts/master/res/announce.mp3,MUSH/sounds",
  }
  return (table.concat(t, ";"))
end



-----------------
-- tables stuff
-----------------

function find_index(t, item)
  res = nil

  for i = 1, #t do
    if (string.lower(t[i]) == string.lower(item)) then
      res = i
      break
    end
  end

  return res
end


function add_to_table(t, item)
  local i = find_index(t, item)
  if (not i) then
    t[#t + 1] = item
    table.sort(t) -- keep it sorted alphabetically
  end
end


function del_from_table(t, item)
  local i = find_index(t, item)
  if (i) then
    table.remove(t, i)
  end
end



----------------
-- lists stuff
----------------

function list_to_table(list)
  local list = GetVariable(list)
  local t
  if (not list) or (list == "") then
    t = {}
  else
    t = utils.split(list, "|")
  end
  return t
end


function add_to_list(list, item)
  local t = list_to_table(list)
  add_to_table(t, item)
  SetVariable(list, table.concat(t, "|"))
end


function del_from_list(list, item)
  local t = list_to_table(list)
  del_from_table(t, item)
  SetVariable(list, table.concat(t, "|"))
end


function is_listed(list, item)
  local t = list_to_table(list)
  return (find_index(t, item) ~= nil)
end



---------
-- imms
---------

function add_imms()
  local oldlist = Trim(GetVariable("imms") or "")
  if (oldlist == "") then
    oldlist = "Duende|Elana|Esker|Iyara|Lanasar|Moirae|Omnis|Satina|Sekhet|Sueno"
  end
  oldlist = string.gsub(oldlist, "|", "\r\n")

  local list = utils.editbox("Type a list of names, one per line.\r\nPress OK when you're done.", "Imms", oldlist, "Lucida Console", 9)

  if (list) then
    while(string.find(list, "\r\n\r\n")) do
      list = string.gsub(list, "\r\n\r\n", "\r\n")
    end

    while(string.find(list, " ")) do
      list = string.gsub(list, " ", "")
    end

    list = string.gsub(list, "\r\n", "|")
    list = string.gsub(list, "\n", "|")
    list = string.gsub(list, "\r", "|")

    SetVariable("imms", list)
    SaveState()
  end
end



-------------------------
-- manage capture types
-------------------------

function init_captures_list()
  SetVariable("all_channel_types", "alliance|announce|archon|auction|aucverb|clan|form|guide|irc|ircverb|notify|novice|page|relay|say|shout|talk|tell|yell")

  local default_channel_types = "alliance|announce|archon|clan|form|guide|notify|novice|page|relay|shout|talk|tell|yell"

  local x = GetVariable("captures")
  if (x == nil) or (x == "") then
    -- default is full list minus auction|say
    SetVariable("captures", default_channel_types)
    SaveState()

  else
    if (string.find(x, "private")) then
      uncapture_chantype("private")
      capture_chantype("notify")
      capture_chantype("page")
      capture_chantype("tell")
    end

    if (string.find(x, "public")) then
      uncapture_chantype("public")
      capture_chantype("archon")
      capture_chantype("talk")
      capture_chantype("shout")
      capture_chantype("yell")
    end
  end

  BroadcastPlugin(0, GetVariable("captures"))
end


function capture_chantype(chantype)
  local t = utils.split(chantype, " ")

  if (t[1] == "relay") then
    if (t[2]) then
      add_relay(t[2])

    else
      Tell("-- capture2dworld: type ")
      ColourTell("silver", "black", "capture relay <chatroomname>")
      Note(" (eg, capture relay sightimpaired) --")
    end

  else
    if (is_listed("all_channel_types", t[1])) then
      if (not is_listed("captures", t[1])) then
        add_to_list("captures", t[1])
        SaveState()
        Tell("-- capture2dworld: added channel ")
        ColourTell("silver", "black", t[1])
        Note(" to the list of captures --")

        BroadcastPlugin(0, GetVariable("captures"))

      else
        Note("-- capture2dworld: '" .. t[1] .. "' is already in the list of captures --")
      end

    else
      Note("-- capture2dworld: '" .. t[1] .. "' is not supported --")
    end
  end
end


function uncapture_chantype(chantype)
  local t = utils.split(chantype, " ")

  if (t[1] == "relay") then
    del_relay(t[2])

  else
    if (is_listed("captures", t[1])) then
      del_from_list("captures", t[1])
      SaveState()
      Tell("-- capture2dworld: removed channel ")
      ColourTell("silver", "black", t[1])
      Note(" from the list of captures --")

      BroadcastPlugin(0, GetVariable("captures"))

    else
      Note("-- capture2dworld: '" .. t[1] .. "' is not in the list of captures --")
    end
  end
end


function get_captures_list()
  local aux = GetVariable("captures") or "-"

  return aux
end


function list_captures()
  Note("-- capture2dworld --")
  Tell("* showing channel types: ")

  local capt = GetVariable("captures") or "-"
  capt = string.gsub(capt, "|", ", ")

  local all = GetVariable("all_channel_types") or "-"
  all = string.gsub(all, "|", ", ")

  ColourNote("silver", "black", capt)
  Note("(out of this full list: " .. all .. ")")

  list_relays(false)
end



------------------
-- manage relays
------------------

function add_relay(rname)
  if (not is_listed("captures", "relay")) then
    capture_chantype("relay")
  end

  if (not is_listed("relays", rname)) then
    add_to_list("relays", rname)
    SaveState()
    Tell("-- capture2dworld: added relay ")
    ColourTell("silver", "black", rname)
    Note(" to the list of captures --")

  else
    Note("-- capture2dworld: that relay is already in the list of captures --")
  end
end


function del_relay(rname)
  if (is_listed("relays", rname)) then
    del_from_list("relays", rname)
    SaveState()
    Tell("-- capture2dworld: removed relay ")
    ColourTell("silver", "black", rname)
    Note(" from the list of captures --")

  else
    Note("-- capture2dworld: that relay is not in the list of captures --")
  end
end


function list_relays(show_header)
  if (show_header) then
    Note("-- capture2dworld --")
  end

  local rel = GetVariable("relays") or "-"
  rel = string.gsub(rel, "|", ", ")

  Tell("* showing relays: ")
  ColourNote("silver", "black", rel)
end



---------------------------
-- manage content filters
---------------------------

function add_content_filter(ftype, fname)
  -- ftype is char|word

  fname = Trim(fname)
  local aux = string.lower(fname)

  ftype = "filtered_" .. ftype .. "s"

  if (not is_listed(ftype, aux)) then
    add_to_list(ftype, aux)
    SaveState()
    Tell("-- capture2dworld: added " .. ftype .. " ")
    ColourTell("silver", "black", fname)
    Note(" to the list of filters --")

  else
    Note("-- capture2dworld: " .. fname .. " is already in the " .. ftype .. " list --")
  end
end


function del_content_filter(ftype, fname)
  -- ftype is char|word

  fname = Trim(fname)
  local aux = string.lower(fname)

  ftype = "filtered_" .. ftype .. "s"

  if (is_listed(ftype, aux)) then
    del_from_list(ftype, aux)
    SaveState()
    Tell("-- capture2dworld: removed " .. ftype .. " ")
    ColourTell("silver", "black", fname)
    Note(" from the list of filters --")

  else
    Note("-- capture2dworld: " .. fname .. " is not in the " .. ftype .. " list --")
  end
end


function list_content_filters()
  Note("-- capture2dworld: content filters --")
  Tell("* NPCs / PCs: ")
  ColourNote("silver", "black", GetVariable("filtered_chars") or "-")
  Tell("* words: ")
  ColourNote("silver", "black", GetVariable("filtered_words") or "-")
end



---------
-- gags
---------

function is_gagged(name)
  local res, val

  res, val = CallPlugin("8928fc500d37775d54b86a56", "is_gagged", name)

  if (res ~= 0) then
    val = nil
  end

  return val
end



----------------------------------
-- broadcasts from other plugins
----------------------------------

function OnPluginBroadcast(msg, id, pname, text)
  if (id == "51a661f409c5d66601ff16e9") -- comm_stuff
  and (pname == "comm_stuff") then
    if (msg == 1) then
      handle_irc_msg(text)
    end

  elseif (id == "f67c4339ed0591a5b010d05b") then -- GMCP message
    if (text == "char.gecho_notification") then -- gecho
      get_gmcp_gecho()
      handle_gmcp_gecho()
    end

  elseif (id == "fbd5b7cc1ef6acf827a3f4a1") then -- plugins_updater_v2
    if (msg == 1) then
      Note(text)
      handle_gmcp_gecho(text)
    end
  end
end



---------
-- gmcp
---------

function get_gmcp_gecho()
  local res, gmcparg = CallPlugin("f67c4339ed0591a5b010d05b", "gmcpval", "char.gecho_notification")
  luastmt = "gmcpdata = " .. gmcparg

--  Note("gmcparg: " .. (gmcparg or "nil"))

  assert(loadstring(luastmt or ""))()
end


function simulate()
  handle_gmcp_gecho("debug")
end


function do_simulate()
  local t_sims = {
    "\n\r\n\r|W|Z117Humpty|X |z117Dumpty|X|X\n\r\n\r",
    "\n\r\n\r|W|Z039Humpty Dumpty|X|X\n\r\n\r",
    "\n\r\n\r|Wjack |z189jump |1over |Xthe |1|z213candlestick|x|X\n\r\n\r",
    "\n\r\n\r|W|z188jack |xbe |Cquick|X\n\r\n\r",
    "\n\r\n\r|W|z157jack be nimble|X|X\n\r\n\r",
    "\n\r\n\r|W|z117 all the night|X|X\n\r\n\r",
    "\n\r\n\r|W|z105 twinkle, twinkle,|X|X\n\r\n\r",
    "\n\r\n\r|W|X|2|RThen you show your |3|Clittle light|X|X\n\r\n\r",
    "\n\r\n\r|W|X|1|Rwhen nothing shines above|X|X\n\r\n\r",
    "\n\r\n\r|W|X|1|Gwhen the blazing sun is gone|X|X\n\r\n\r",
    "\n\r\n\r|W|1like |Xa |Wdiamond|X in the |Csky|X\n\r\n\r",
    "\n\r\n\r|Wthe |bworld |Xso high|X\n\r\n\r",
    "\n\r\n\r|Wup |Rabove|X\n\r\n\r",
    "\n\r\n\r|W|Cwho you |gare|X\n\r\n\r",
    "\n\r\n\r|W|Yhow I wonder|X\n\r\n\r",
    "\n\r\n\r|W|Blittle star|X\n\r\n\r",
    "\n\r\n\r|Wtwinkle twinkle|X\n\r\n\r",
  }

  return t_sims[math.random(#t_sims)]
end


function handle_gmcp_gecho(msg)
  if (not msg) then
    msg = gmcpval("gecho_msg")

  elseif (msg == "debug") then
    msg = do_simulate()

  --msg not nil, not "debug" => process it as it comes
  end

  if (reader_present) then
    handle_gmcp_gecho_v1_nocolors(msg)
  else
    handle_gmcp_gecho_v2_colors(msg)
  end
end


function handle_gmcp_gecho_v1_nocolors(msg)
  if (msg) then
    msg = strip_colors(msg)
    msg = strip_crlfs(msg)

    for line in string.gmatch(msg, "[^§]*§") do
      line = string.match(line, "(.+)§")
      line = Trim(line or "")

      if (line ~= "") then
--        Note("broadcasting: " .. line)
        broadcast_txt_line("announce", line, "")
      end
    end
  end
end


function handle_gmcp_gecho_v2_colors(msg)
  if (msg) then
    captures = GetWorld("captures") -- checks every time, in case they close it

    show_txt("silver", "black", "\r\n")
    show_txt("silver", "black", "[".. os.date("%H:%M:%S") .. "] ")
--    show_txt("orangered", "black", "[gecho] ")

    local aux = strip_crlfs(msg)

    local fg, bg, col, txt
    fg = "silver"
    bg = "black"

    for x in string.gmatch(aux, "|[^|]*") do
      if (string.find(x, "^|z%d%d%d")) then
        col, txt = string.match(x, "^|z(%d%d%d)(.*)")
        col = RGBColourToName(x256_to_rgb(tonumber(col)))
        if (col) then
          fg = col
        end

      elseif (string.find(x, "^|Z%d%d%d")) then
        col, txt = string.match(x, "^|Z(%d%d%d)(.*)")
        col = RGBColourToName(x256_to_rgb(tonumber(col)))
        if (col) then
          bg = col
        end

      elseif (string.find(x, "^|X")) then
        fg = "silver"
        bg = "black"
        txt = string.match(x, "^|X(.*)")

      elseif (string.find(x, "^|%a")) then
        col, txt = string.match(x, "^|(%a)(.*)")
        col = fg_mm_to_name(col)
        if (col) then
          fg = col
        end

      elseif (string.find(x, "^|%d")) then
        col, txt = string.match(x, "^|(%d)(.*)")
        col = bg_mm_to_name(col)
        if (col) then
          bg = col
        end
      end

      if (txt) then
        if (string.find(txt, "§")) then
          for line in string.gmatch(txt, "[^§]*§") do
            line = string.match(line, "(.+)§")
            line = Trim(line or "")

            if (line ~= "") then
              show_txt(fg, bg, line)

              broadcast_txt_line("announce", line, "")
            end

            show_txt("silver", "black", "\r\n")
          end

        else
          show_txt(fg, bg, txt)

          broadcast_txt_line("announce", txt, "")
        end
      end
    end
  end
end


function strip_colors(msg)
  local res = ""

--  for x in string.gmatch(msg, "[|]*[^|]+") do

  res = string.gsub(msg, "|[xz]%d%d%d", "")
  res = string.gsub(res, "|[%d%a]", "")
  res = Trim(res)

--  end

  return res, white
end


function strip_crlfs(msg)
  msg = string.gsub(msg, "\r", "§")
  msg = string.gsub(msg, "\n", "§")
  msg = msg .. "§"

  while (string.find(msg, "§§")) do
    msg = string.gsub(msg, "§§", "§")
  end

  return msg
end



-----------------------
-- MM colors to names
-----------------------

local code_to_name = {
  ["1"] = "maroon",
  ["2"] = "green",
  ["3"] = "olive",
  ["4"] = "navy",
  ["5"] = "purple",
  ["6"] = "teal",
  ["7"] = "silver",
  ["B"] = "blue",
  ["R"] = "red",
  ["C"] = "cyan",
  ["M"] = "magenta",
  ["Y"] = "yellow",
  ["W"] = "white",
  ["G"] = "lime",
  ["b"] = "navy",
  ["r"] = "maroon",
  ["c"] = "teal",
  ["m"] = "purple",
  ["y"] = "olive",
  ["w"] = "silver",
  ["g"] = "green",
  ["D"] = "gray",
}


function fg_mm_to_name(color)
  local res = code_to_name[color]

  return res
end


function bg_mm_to_name(color)
  local res = code_to_name[color]

  return res
end



----------------
-- x256 to RGB
----------------

local compatibility_16_to_rgb = {
  [0] = 0, -- black
  [1] = 128, -- maroon
  [2] = 32768, -- green
  [3] = 32896, -- olive
  [4] = 8388608, -- navy
  [5] = 8388736, -- purple
  [6] = 8421376, -- teal
  [7] = 12632256, -- silver
  [8] = 8421504, -- gray
  [9] = 255, -- red
  [10] = 65280, -- lime
  [11] = 65535, -- yellow
  [12] = 16711680, -- blue
  [13] = 16711935, -- magenta
  [14] = 16776960, -- cyan
  [15] = 16777215, -- white
}


function x256_to_rgb(x256)
  local r, g, b, rgb

  if (x256 >= 0) and (x256 <= 15) then
    -- compatibility 16
    rgb = compatibility_16_to_rgb[x256]

  elseif (x256 >= 16) and (x256 <= 231) then
    -- cube
    x256 = x256 - 16

    r = math.floor(x256 / 6 / 6)
    x256 = x256 - (r * 6 * 6)
    g = math.floor(x256 / 6)
    b = x256 - (g * 6)

    rgb = (256 * 256 * to255(b)) + (256 * to255(g)) + to255(r)

  elseif (x256 >= 232) and (x256 <= 255) then
    -- grayscale
    x256 = x256 - 232

    rgb = (256 * 256 * to255gray(x256)) + (256 * to255gray(x256)) + to255gray(x256)
  end

  return rgb
end


function to255(num)
  return num * 51
end


function to255gray(num)
  return 8 + (num * 10)
end



--------
-- irc
--------

function handle_irc_msg(text)
--  Note("Got an IRC msg")
  if (is_listed("captures", "irc"))
  or (is_listed("captures", "ircverb"))  then
--    Note("Capturing IRC msgs")
    local user, extuser, msg = string.match(text, "(.+);(.+);(.+)")

--    Note("user: " .. (user or "nil"))
--    Note("extuser: " .. (extuser or "nil"))
--    Note("msg: " .. (msg or "nil"))

    if (not string.match(msg, "^§.+"))
    or (is_listed("captures", "ircverb")) then
      captures = GetWorld("captures") -- gotta check every time in case they close it
--      Note("trying to show it")
      show_txt("silver", "black", "\r\n")
      show_txt("silver", "black", "[".. os.date("%H:%M:%S") .. "] ")
      show_txt("springgreen", "black", "[irc] ")
      show_txt("white", "black", extuser .. ": ")

      if (string.find(extuser, "#")) then
        show_txt("silver", "text", msg)
      else
        show_txt("gray", "text", msg)
      end

      show_txt("silver", "black", "\r\n")
    end
  end
end



------------------
-- show captures
------------------

function capture_stuff(who, type, line, recolor)
-- who needs to be not nil,
  if (type ~= "relay") then
    -- broadcast _unfiltered_ text-only info, for capture2notepads and similar plugins
    broadcast_txt_line(type, line, who)
  end

  if (is_listed("captures", type)) then
--    if (type ~= "guide") then
      -- check if the person is being filtered out
      who = string.lower(extract_name(who))

      if (not is_listed("filtered_chars", who))
      and (not is_gagged(who)) then
        add_to_captures_world(who, type, recolor)
      end

--    else
--    -- we DON'T apply filters to guide
--      add_to_captures_world(who, type, recolor)
--    end
  end
end


function broadcast_txt_line(type, line, who)
  -- broadcast text-only info, for capture2notepads and similar plugins
  local t = {
    [1] = type,
    [2] = line,
    [3] = who,
  }
  BroadcastPlugin(2, table.concat(t, "Ø"))
end


function extract_name(name)
  if (string.find(name, "^The shade of ")) then
    name = string.gsub(name, "^The shade of ", "")

  elseif (string.find(name, "([%s%p])disguised as ")) then
    name = string.gsub(name, "%pdisguised as ", "disguised as ")
    name, _ = string.match(name, "(.+) disguised as (.+)")
  end

  return name
end


function add_to_captures_world(who, type, recolor)
  local txt, fgcol, bgcol

  captures = GetWorld("captures") -- gotta check every time in case they close it

  show_txt("silver", "black", "\r\n")
  show_txt("silver", "black", "[".. os.date("%H:%M:%S") .. "] ")

  for i = 1, #trigger_style_runs do
    txt = trigger_style_runs[i].text

    -- shorten Novice clan name
    if (string.find(txt, "Novice")) then
      txt = string.gsub(txt, "%[CLAN Novice Adventurers%]", "%[Novice%]")
      txt = string.gsub(txt, "Novice clan members", "Novices")
      txt = string.gsub(txt, "Novice clan member", "Novice")
    end

    -- shorten Vandemaar's Magic Mirror
    if (string.find(txt, "Vandemaar's Magic Mirror")) then
      txt = string.gsub(txt, "^You hear (.+) say through Vandemaar's Magic Mirror:", "%(mirror%) %1:")
    end

    -- we only apply word filters if it isn't the guide channel
    if (type ~= "guide") then
      -- filter out words in the message
      txt = filter_all_words(txt)
    end

    fgcol = RGBColourToName(trigger_style_runs[i].textcolour)
    bgcol = RGBColourToName(trigger_style_runs[i].backcolour)

    show_txt(fgcol, bgcol, txt)
  end

  show_txt("silver", "black", "\r\n")
end


function show_txt(fgcol, bgcol, txt)
  if (captures) then
    captures:ColourTell(fgcol, bgcol, txt)
  end

  -- broadcast _filtered_ info, for capture2mini and similar plugins
  local t = {
    [1] = fgcol,
    [2] = bgcol,
    [3] = txt,
  }
  BroadcastPlugin(1, table.concat(t, "Ø"))
end


function clear_captures()
  local captures = GetWorld("captures")
  if (captures ~= nil) then
    captures:DeleteOutput()
    captures:Pause(false)
  end
end



----------------------
-- filtered captures
----------------------

function capture_alliance(who, line)
  -- add to this table the list of stuff that you don't want to be captured
  -- eg, keywords from bots output
  local omit_from_alliance = {
  }

  for i = 1, #omit_from_alliance do
    if (string.find(line, omit_from_alliance[i])) then
      return
    end
  end

  capture_stuff(who, "alliance", line, true)
end


function capture_announce(who, line)
  -- do include arena results
  if (string.find(line, "has been slain by"))
  and (string.find(line, "in Arena combat")) then
    capture_stuff(who, "announce", line, false)
    return
  end

  -- add to this table the list of stuff that you don't want to be captured
  local omit_from_announce = {
    "A Capture The Flag coordinator announces",
    "has the blue flag",
    "has the red flag",
    "has recovered the blue flag",
    "has recovered the red flag",
    "has scored a point for the blue team",
    "has scored a point for the red team",
    "has been slain by",
    "has reduced my integrity by",
    "Feel my demise in your heart",
  }

  for i = 1, #omit_from_announce do
    if (string.find(line, omit_from_announce[i])) then
      return
    end
  end

  capture_stuff(who, "announce", line, false)
end


function capture_archon_talk(who, line)
  -- add to this table the list of stuff that you don't want to be captured
  local omit_from_archon_talk = {
  }

  for i = 1, #omit_from_archon_talk do
    if (string.find(line, omit_from_archon_talk[i])) then
      return
    end
  end

  capture_stuff(who, "archon", line, false)
end


function capture_clan(who, line)
  -- add to this table the list of stuff that you don't want to be captured
  -- eg, keywords from bots output
  local omit_from_clan = {
  }

  for i = 1, #omit_from_clan do
    if (string.find(line, omit_from_clan[i])) then
      return
    end
  end

  capture_stuff(who, "clan", line, true)
end


function capture_guide(who, what, line)
  -- add to this table the list of stuff that you don't want to be captured
  local omit_from_guide = {
    "There are no player guides currently enabled",
    "idling in Lasler: If you can and nobody else has",
    "has joined the game at",
  }

  for i = 1, #omit_from_guide do
    if (string.find(line, omit_from_guide[i])) then
      return
    end
  end

  local t = utils.split(what, " ")
  if (t[1] == "says") then
    capture_stuff(who, "guide", line, false)
  else
    capture_stuff("", "guide", line, false)
  end
end


function capture_other(who, what, line)
  if (not string.match(what, "^ (%s+)(.+)"))
  and (not string.match(what, "^(%s+)%[(.+)")) then
    capture_stuff(who, "guide", line, false)
  end
end


function capture_relay(who, chan, line)
  -- broadcast _unfiltered_ text-only info, for capture2notepads and similar plugins
  broadcast_txt_line("relay", line, who)

  if (is_listed("relays", chan)) then
    capture_stuff(who, "relay", line, false)
  end
end


function capture_shout(who, line)
  -- add to this table the list of stuff that you don't want to be captured
  -- eg, certain game announcements
  local omit_from_shout = {
    "Shop the fine wares at the Alyrian Bazaar",
    "Hear ye, hear ye, adventurers of",
    "back from a long absence!",
  }

  for i = 1, #omit_from_shout do
    if (string.find(line, omit_from_shout[i])) then
      return
    end
  end

  capture_stuff(who, "shout", line, true)
end


function capture_yell(who, line)
  -- add to this table the list of stuff that you don't want to be captured
  -- eg, certain game announcements
  local omit_from_yell = {
    "available in Agatha's Shoppe of Illusions!",
    "A masculine voice yells",
    "Ferry is now docked at",
    "The ship Merdraco be docked at",
  }

  for i = 1, #omit_from_yell do
    if (string.find(line, omit_from_yell[i])) then
      return
    end
  end

  capture_stuff(who, "yell", line, true)
end



-----------------
-- filter words
-----------------

function nocase(s)
  s = string.gsub(s, "%a",
                  function(c)
                    return string.format("[%s%s]",
                                         string.lower(c),
                                         string.upper(c))
      end)
  return s
end


function filter_word(s, word)
  beeped_subst = "*beeped*" -- edit this if you don't like it

  -- just the word
  s = string.gsub(s, "^" .. nocase(word) .. "$", beeped_subst)

  -- beginning of the line
  s = string.gsub(s, "^" .. nocase(word) .. "([%p%s])", beeped_subst .. "%1")

  -- end of the line
  s = string.gsub(s, "([%p%s])" .. nocase(word) .. "$", "%1" .. beeped_subst)

  -- middle of the line
  s = string.gsub(s, "([%p%s])" .. nocase(word) .. "([%s%p])", "%1" .. beeped_subst .. "%2")

  return s
end


function filter_all_words(s)
  tfilter = list_to_table("filtered_words")

  for i = 1, #tfilter do
    s = filter_word(s, tfilter[i])
  end

  return s
end



----------------
-- sound stuff
----------------

function reader_plugin_present()
  return is_plugin_present("MushReader", "925cdd0331023d9f0b8f05a7")
end


]]>

</script>

</muclient>
